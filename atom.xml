<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[i4box's Blog]]></title>
  <link href="http://i4box.com/atom.xml" rel="self"/>
  <link href="http://i4box.com/"/>
  <updated>2016-04-06T08:57:54+08:00</updated>
  <id>http://i4box.com/</id>
  <author>
    <name><![CDATA[i4box]]></name>
    <email><![CDATA[jinhao2011@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang atomic.Value]]></title>
    <link href="http://i4box.com/blog/2016/03/31/golang-atomic-dot-value/"/>
    <updated>2016-03-31T11:46:51+08:00</updated>
    <id>http://i4box.com/blog/2016/03/31/golang-atomic-dot-value</id>
    <content type="html"><![CDATA[<h2>参考</h2>

<p><a href="https://texlution.com/post/golang-lock-free-values-with-atomic-value/">https://texlution.com/post/golang-lock-free-values-with-atomic-value/</a>
<a href="https://golang.org/pkg/sync/atomic/#example_Value_readMostly">https://golang.org/pkg/sync/atomic/#example_Value_readMostly</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Race Free 学习]]></title>
    <link href="http://i4box.com/blog/2016/03/31/race-free-li-jie/"/>
    <updated>2016-03-31T11:45:56+08:00</updated>
    <id>http://i4box.com/blog/2016/03/31/race-free-li-jie</id>
    <content type="html"><![CDATA[<p>最近准备将<a href="https://github.com/Terry-Mao/gopush-cluster/blob/master/rpc/rand_lb.go#L232">gopush代码中</a>rpc模块提出来复用一下，看到这样段代码，很是不解：</p>

<pre><code>        tmpClients := make(map[string]*WeightRpc, len(r.Clients))
        for addr, client := range r.Clients {
            if client == nil {
                continue
            }
            tmpClients[addr] = client
            if client.Addr == retryAddr {
                client.Client = rpcTmp
            }
        }
        // atomic update clients
        r.Clients = tmpClients
</code></pre>

<p> <!-- more --></p>

<p>代码中需要更新<code>map[string]*WeightRpc</code>这个Clients<em>(该Clients只被这一个goroutine修改，其他多个goroutine回去读)</em>，作者先copy一个临时的map，进行修改后，直接赋值给原map，并注释上这样是原子更新。</p>

<p>以我的理解，这种赋值操作肯定不是原子的，这个赋值操作编译成汇编，生成多个汇编指令，每个汇编指令都可能被中断，因此读该map的goroutine就有可能读到这个赋值的中间状态。于是我就在提了个<a href="https://github.com/Terry-Mao/gopush-cluster/issues/44">issue</a>，期望得到作者的解答(目测该项目已经不维护了)。</p>

<h4>求助万能的google：</h4>

<p>找到了<a href="http://yanyiwu.com/work/2015/02/07/golang-concurrency-safety.html">《谈谈go语言编程的并发安全》</a>,文中作者说的是golang中string赋值（单写多读），weedfs作者认为这种情况最多读到过期数据，不影响，最终的结论是：这种清晰可能引起各种不可预期的结果。</p>

<h3>关于data race详细介绍，请看下面几篇文章</h3>

<p><a href="http://preshing.com/20130618/atomic-vs-non-atomic-operations/">Atomic vs. Non-Atomic Operations</a></p>

<p><a href="https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong">Benign data races: what could possibly go wrong?</a></p>

<p><a href="http://blog.regehr.org/archives/490">Race Condition vs. Data Race</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang Map 学习]]></title>
    <link href="http://i4box.com/blog/2016/03/31/golang-map-zai-rangeqi-jian-deletecao-zuo-an-quan/"/>
    <updated>2016-03-31T11:21:58+08:00</updated>
    <id>http://i4box.com/blog/2016/03/31/golang-map-zai-rangeqi-jian-deletecao-zuo-an-quan</id>
    <content type="html"><![CDATA[<h3>一、定义</h3>

<ol>
<li><h5>大概是这个样子的：</h5>

<p><code>map[KeyType]ValueType</code></p></li>
<li><h5>传值or传引用</h5>

<p>golang map和string slice一样都为引用类型，传递时默认就是传指针的；</p></li>
<li><h5>声明一个map</h5>

<p><code>var m map[string]int</code>, m默认值为nil，如果直接使用会引起panic，必须先初始化；
<!-- more --></p></li>
<li><h5>初始化</h5>

<p><code>m = make(map[string]int)</code>或者直接定义 <code>m := map[string]int{}</code>;</p></li>
<li><h5>插入</h5>

<p><code>m["hi"] = 1</code>, key不存在相当于插入，存在相当于覆盖</p></li>
<li><h5>删除</h5>

<p><code>delete(m, "hi")</code>,key不存在也没有关系，不会进行任何操作；</p></li>
<li><h5>判断key是否存在</h5>

<p><code>v, ok := m["hi"]</code> key存在则ok返回为<code>true</code>，不存在ok未<code>false</code></p></li>
<li><h5>遍历</h5>

<p><code>for k, v := range map</code></p></li>
</ol>


<h3>二、map遍历操作是无序的</h3>

<p><strong>example</strong></p>

<pre><code>package main

import "fmt"

func main() {
    var m map[int]string
    m = make(map[int]string)
    for i := 0; i &lt; 10; i++ {
        m[i] = "hi" 
    }

    for i := 0; i &lt; 5; i++ {
        for k := range m {
            fmt.Print(k)
            fmt.Print(" ")
        }
        fmt.Println()
    }
}
</code></pre>

<p> <strong>result:</strong></p>

<pre><code>4 5 6 9 7 8 0 1 2 3
1 2 3 7 8 0 5 6 9 4
4 5 6 9 8 0 1 2 3 7
4 5 6 9 7 8 0 1 2 3
1 2 3 7 8 0 5 6 9 4    
</code></pre>

<p> 需要有序遍历只能自己再弄一个sorted slice了，参考<a href="https://blog.golang.org/go-maps-in-action#TOC_7.">官方文档</a></p>

<h3>三、并发访问安全</h3>

<p> <a href="https://blog.golang.org/go-maps-in-action#TOC_6.">https://blog.golang.org/go-maps-in-action#TOC_6.</a></p>

<h3>四、在range期间delete操作安全</h3>

<h4>结论</h4>

<p>range期间delete操作是安全的</p>

<h4>详细介绍</h4>

<p><a href="http://stackoverflow.com/questions/23229975/is-it-safe-to-remove-selected-keys-from-golang-map-within-a-range-loop">http://stackoverflow.com/questions/23229975/is-it-safe-to-remove-selected-keys-from-golang-map-within-a-range-loop</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TCP重传相关几个参数]]></title>
    <link href="http://i4box.com/blog/2015/03/05/tcpzhong-chuan-xiang-guan-ji-ge-can-shu/"/>
    <updated>2015-03-05T16:58:44+08:00</updated>
    <id>http://i4box.com/blog/2015/03/05/tcpzhong-chuan-xiang-guan-ji-ge-can-shu</id>
    <content type="html"><![CDATA[<p>看过TCP协议的，我们都知道TCP send一个数据包，如果对端没有给响应(ack), tcp会进行重传，但是重传指定次数后，若一直失败（如网络中断了），最终错误码是什么了？之前一直也没关心过，今天刚好做了测试，记录一下。</p>

<!-- more -->


<p>先简单说下tcp重传相关的几个参数：</p>

<pre><code>1. tcp_orphan_retries: 主要是针对孤立的socket(也就是已经从进程上下文中删除了，可是还有一些清理工作没有完成).对于这种socket，我们重试的最大的次数就是它。 
2. tcp_retries1: 表示的是最大的重试次数，当超过了这个值，我们就需要检测路由表了。    
3. tcp_retries2: 表示重试最大次数，只不过这个值一般要比上面的值大。和上面那个不同的是，当重试次数超过这个值，我们就必须放弃重试了。  
4. tcp_syn_retries: 默认值一般为5，表示未收到syn/ack,syn分节的重传次数, 重传时间为1s,2s,4s,8s,16s。 
5. tcp_synack_retries: 表示未收到ack，syn/ack重传次数，重传时间间隔也为1s,2s,4s,8s,16s。
</code></pre>

<p>测试方法：通过iptables过滤掉客户端的包。</p>

<p>测试结果：</p>

<ol>
<li>connect重试tcp_syn_retries指定次数后，若还无响应，则connect返回-1， errno:110 errstr:Connection timed out</li>
<li>send发送数据直接返回成功copy到socket缓冲区的字节数，tcp协议栈在未收到对端ack时，重试发送，重试tcp_retries2指定次数后，不再重试，下一次再对该fd进行write操作，将返回ret=-1，errno:110, errstr:Connection timed out.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tcp_max_orphans引起的FIN,RST]]></title>
    <link href="http://i4box.com/blog/2015/01/15/tcp-max-orphansyin-qi-de-fin/"/>
    <updated>2015-01-15T19:12:53+08:00</updated>
    <id>http://i4box.com/blog/2015/01/15/tcp-max-orphansyin-qi-de-fin</id>
    <content type="html"><![CDATA[<p>先看一个tcpdump的抓包</p>

<pre><code>19:08:01.196965 IP 172.16.91.101.10001 &gt; 172.16.91.107.6388: Flags [S], seq 475071557, win 1460, options [mss 1460,nop,nop,sackOK,nop,wscale 10], length 0
19:08:01.197002 IP 172.16.91.107.6388 &gt; 172.16.91.101.10001: Flags [S.], seq 2477638798, ack 475071558, win 1460, options [mss 1460,nop,nop,sackOK,nop,wscale 10], length 0
19:08:01.197216 IP 172.16.91.101.10001 &gt; 172.16.91.107.6388: Flags [.], ack 1, win 2, length 0
19:08:03.032342 IP 172.16.91.101.10001 &gt; 172.16.91.107.6388: Flags [F.], seq 1, ack 1, win 2, length 0
19:08:03.032505 IP 172.16.91.101.10001 &gt; 172.16.91.107.6388: Flags [R.], seq 2, ack 1, win 2, length 0
19:08:03.032515 IP 172.16.91.107.6388 &gt; 172.16.91.101.10001: Flags [F.], seq 1, ack 2, win 2, length 0
19:08:03.032845 IP 172.16.91.101.10001 &gt; 172.16.91.107.6388: Flags [R], seq 475071559, win 0, length 0
</code></pre>

<!-- more -->


<p>客户端正常建立连接后，就调用close，抓包显示客户端先发送了FIN包，紧接着又发送了一个RST包，现象看起来实在是奇怪，google之，也未发现介绍这种场景的RST；换了台机器测试，发现4次挥手正常，于是查看tcp相关sysctl参数，发现了这个参数设置(想起来之前测试<a href="http://i4box.com/blog/2014/11/08/fin-wait1zhuang-tai-ce-shi/">tcp_max_orphans</a>参数对TIME_WAIT影响时设置，未取消)：</p>

<blockquote><p>net.ipv4.tcp_max_orphans = 0</p></blockquote>

<p>关于tcp_max_orphans参数介绍</p>

<blockquote><p>Maximal number of TCP sockets not attached to any user file handle, held by system. If this number is exceeded orphaned connections are reset immediately and warning is printed. This limit exists only to prevent simple DoS attacks, you must not rely on this or lower the limit artificially, but rather increase it (probably, after increasing installed memory), if network conditions require more than default value, and tune network services to linger and kill such states more aggressively. Let me to remind again: each orphan eats up to ~64 KB of unswappable memory.</p></blockquote>

<p>另外一个对应参数：tcp_orphan_retries</p>

<blockquote><p>How may times to retry before killing TCP connection, closed by our side. Default value 7 corresponds to  50sec-16min depending on RTO. If your machine is a loaded WEB server, you should think about lowering this value, such sockets may consume significant resources. Cf. tcp_max_orphans</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stl Set_defference 和 Inserter使用]]></title>
    <link href="http://i4box.com/blog/2014/11/27/stl-set-defference-he-insertershi-yong/"/>
    <updated>2014-11-27T22:12:10+08:00</updated>
    <id>http://i4box.com/blog/2014/11/27/stl-set-defference-he-insertershi-yong</id>
    <content type="html"><![CDATA[<p>今天在弄通过zookeeper动态更新服务列表<code>new_list</code>，由于我这边在做的时一个动态连接池管理，获取到得服务列表后是要与服务列表中得地址建立连接的，更新服务列表时自然也不能简单的直接覆盖老服务列表<code>old_list</code>。</p>

<!-- more -->


<ul>
<li><p>方法1</p>

<blockquote><p>将<code>new_list</code>中每个member在<code>old_list</code>中遍历一遍，在<code>old_list</code>已经存在的member做上标记，不存在的member建立连接后加入<code>old_list</code>，全部遍历完成后，再遍历一遍<code>old_list</code>将未做标记的member移除。</p></blockquote></li>
<li><p>方法2</p>

<blockquote><p>直接使用stl中算法函数:<a href="http://www.cplusplus.com/reference/algorithm/set_difference/">std::set_difference</a>, 该算法函数可以将两个<a href="http://www.cplusplus.com/reference/set/set/">set</a>(也可以是其他的container)中前一个<a href="http://www.cplusplus.com/reference/set/set/">set</a>中包含，而后一个set中没有的member保存到另外一个<a href="http://www.cplusplus.com/reference/set/set/">set</a>中。这样我就可以很容易将<code>old_list</code>中已经不在<code>new_list</code>中得member筛选出来移除掉，另外将new_list中存在的而old_list中不存在的建立连接后加入。</p></blockquote></li>
</ul>


<p>使用方法如下：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;

void print_set(const std::set&lt;std::string&gt;&amp; s)
{
    std::set&lt;std::string&gt;::const_iterator itor;
    for (itor= s.begin(); itor != s.end(); ++itor)
    {
        printf("%s\n", (*itor).c_str());
    }
}

int main(int argc, char* argv[])
{
    std::set&lt;std::string&gt; set1;
    std::set&lt;std::string&gt; set2;

    set1.insert("192.168.60.71:11201");
    set1.insert("192.168.60.72:11101");
    set1.insert("192.168.70.111:11222");
    set1.insert("192.168.70.111:10222");
    set1.insert("192.168.73.111:10222");
    //printf("set1:\n");
    //print_set(set1);

    set2.insert("192.168.70.111:10222");
    set2.insert("192.168.70.111:11222");
    set2.insert("192.168.60.71:11201");
    set2.insert("192.168.60.72:11101");
    //printf("set2:\n");
    //print_set(set2);

    std::set&lt;std::string&gt; rlt;
    std::set_difference(set1.begin(), set1.end(), set2.begin(), set2.end(),
    std::inserter(rlt, rlt.end()));

    //printf("diff:\n");
    print_set(rlt);

    return 0;
}
</code></pre>

<p>结果如下：</p>

<blockquote><p>192.168.73.111:10222</p></blockquote>

<p>代码中std::<a href="http://www.cplusplus.com/reference/iterator/inserter/">inserter</a>是一个模板函数，生成一个插入迭代器<a href="http://www.cplusplus.com/reference/iterator/inserter/">insert_iterator</a>,详细介绍参考<a href="http://www.cplusplus.com">www.cplusplus.com</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fin_wait1状态测试]]></title>
    <link href="http://i4box.com/blog/2014/11/08/fin-wait1zhuang-tai-ce-shi/"/>
    <updated>2014-11-08T14:47:12+08:00</updated>
    <id>http://i4box.com/blog/2014/11/08/fin-wait1zhuang-tai-ce-shi</id>
    <content type="html"><![CDATA[<p>近日由于<a href="https://github.com/wangbin579/tcpcopy/">tcpcopy</a>群里面在讨论tcp的fin_wait1状态如何消除,以及相关系统阐述修改对fin_wait1状态的影响。
关于fin_wait1状态可先参考<a href="http://huoding.com/2014/11/06/383" title="关于FIN_WAIT1">火丁笔记</a>。</p>

<h2>以下是我的测试</h2>

<!-- more -->


<ul>
<li>系统环境

<blockquote><p>ubuntu12.04  <br/>
内核版本3.5.0-23-generic</p></blockquote></li>
<li><p>测试场景1</p>

<ol>
<li> 服务端172.16.91.101，端口9981，客户端172.16.91.107(通过nc模拟的）</li>
<li> 服务端设置系统参数如下：

<blockquote><p><code>net.ipv4.tcp_max_orphans = 1</code><br/>
<code>net.ipv4.tcp_orphan_retries = 8</code></p></blockquote></li>
<li> 客户端先去连接服务端</li>
<li> 在91.107上通过iptables过滤掉发给101的包<code>iptables -A OUTPUT -d 172.16.91.101 -j DROP</code></li>
<li> ctrl+c关闭服务端，观察与91.107建立的连接状态如下:

<blockquote><p>FIN-WAIT-1 0      1           172.16.91.101:9981         172.16.91.107:55602</p></blockquote></li>
<li>  tcpdump抓包如下：可有看到fin发送在服务端刚好尝试了8次
  <img src="http://i4box.com/images/2014/11/08tcpdump-retry8.png" alt=" tcpdump png " />
<strong>结论：</strong><code>tcp_orphan_retries</code>参数为tcp对于处于orphan状态连接的重试次数</li>
</ol>
</li>
<li><p>测试场景2</p>

<ol>
<li> 与场景1相同，只修改系统参数如下：

<blockquote><p><code>net.ipv4.tcp_max_orphans = 0</code></p></blockquote></li>
<li>  通过ss命令看不到fin-wait-1状态</li>
<li>  抓包结果如下:
  <img src="http://i4box.com/images/2014/11/08orp-0.png" alt=" tcpdump png " />
<strong>结论：</strong>由于<code>tcp_max_prphans</code>等于0，因此tcp发送完fin包后直接发送了一个rst包给客户端 (另外经过测试，不在客户端通过iptables过滤掉发送给服务端的包，抓包结果相同，可见服务端发送完fin包后，根本没有等待客户端的ack）。</li>
</ol>
</li>
<li><p>测试场景3</p>

<ol>
<li> 客户端（91.107）连接上服务端（91.101）后，服务端发送大量数据给客户端，直到客户接收缓冲区满了为止，而客户端不接收数据；</li>
<li> 内核参数如下：

<blockquote><p><code>net.ipv4.tcp_max_orphans = 1</code><br/>
<code>net.ipv4.tcp_orphan_retries = 1</code></p></blockquote></li>
<li> 等客户端接收缓存区满了之后，ctrl + c关闭服务端</li>
<li> 观察tcp连接状态，处于orphan状态</li>
<li> 观察tcp抓包，由于tcp缓冲区已满，服务端一直给客户端发送<strong>zero window probes</strong>包，没有发送fin包。</li>
<li> 修改<code>net.ipv4.tcp_max_orphans = 0</code>,继续观察抓包，发现，一会后服务端发送了rst包，orphan状态连接消失。<br/>
<em>tcpdump抓包如下：</em>
  <img src="http://i4box.com/images/2014/11/08tcpdump-fin1.jpg" alt=" tcpdump png " />
<strong>结论：</strong> 在测试系统和对应内核下，修改系统参数<code>net.ipv4.tcp_max_orphans = 0</code>, 可消除orphan状态连接。</li>
</ol>
</li>
</ul>


<p>另：tcpcopy社区讨论中，有部分人测试修改后无效，可能由于老版本内核不支持，据群里面<strong>lazio大神说</strong>最新内核代码看貌似Max参数起了作用。</p>

<p>关于orphan相关内核源码分析，可以参考<a href="http://blog.tsunanet.net/2011/03/out-of-socket-memory.html">http://blog.tsunanet.net/2011/03/out-of-socket-memory.html</a></p>

<p><em>最后，以上结果由本人测试得出，若其中错误，还请指出。</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Github上搭建blog资料整理]]></title>
    <link href="http://i4box.com/blog/2014/10/31/number-githubshang-da-jian-blogzi-liao-zheng-li/"/>
    <updated>2014-10-31T13:48:59+08:00</updated>
    <id>http://i4box.com/blog/2014/10/31/number-githubshang-da-jian-blogzi-liao-zheng-li</id>
    <content type="html"><![CDATA[<h3>资料整理</h3>

<p>通过github pages搭建自己博客相关资料整理:</p>

<ul>
<li><a href="http://blog.csdn.net/grunmin/article/details/14127653">octopress博客搭建和个性化配置</a></li>
</ul>


<!-- more -->


<ul>
<li><p><a href="https://pages.github.com/">github pages 介绍</a></p></li>
<li><p><a href="http://www.zhihu.com/question/20962496">如何在github上写博客(知乎)</a></p></li>
<li><p><a href="http://octopress.org/docs/">Octopress文档</a></p></li>
<li><p><a href="http://icodeit.org/2012/10/how-to-embed-douban-show-in-your-octopress-site/">How to Embed Douban-Show in Your Octopress Site</a></p></li>
<li><p><a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">象写程序一样写博客：搭建基于github的博客</a></p></li>
<li><p><a href="http://blog.csdn.net/lcliliil/article/details/13727927">添加统计和摘要显示</a></p></li>
</ul>


<h3>问题整理</h3>

<p><strong>部署失败 [error: failed to push some refs to <a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#x6d;</a> xxxx&#8217;]</strong>(<a href="http://stackoverflow.com/questions/21356212/failed-to-deploy-to-github-pages-using-octopress">http://stackoverflow.com/questions/21356212/failed-to-deploy-to-github-pages-using-octopress</a>)</p>

<p><strong>解决方法</strong></p>

<blockquote><ul>
<li><code>cd _deploy</code></li>
<li><code>git config branch.master.remote origin</code></li>
<li><code>git config branch.master.merge refs/heads/master</code></li>
<li><code>git pull</code></li>
</ul>
</blockquote>

<p><strong>访问速度过慢?</strong></p>

<p><strong>解决方法</strong></p>

<blockquote><ul>
<li>将博客从github同步到gitcafe上，gitcafe在国内访问速度快很多</li>
<li><a href="http://imxylz.com/blog/2013/09/22/move-google-fonts-to-local-server/">google字体下载到本地</a></li>
<li>若还慢可用Firefox查看下具体打开页面时哪一块比较慢</li>
<li>通过360<a href="http://ce.cloud.360.cn/">奇云测</a>检测下全国各地访问你博客的速度</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
</feed>
